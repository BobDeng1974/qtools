/*###########################################################################*/
/*! @page qutest_fixture QUTest&trade; Fixture Reference

@tableofcontents

A QUTest *test fixture* is a regular C or C++ program that contains the @c %main() function as well as a few @ref qs "QS" callback functions (to implement test commands as well as test startup and teardown). The main job of a *test fixture* is to exercise the CUT (Code Under Test).

The CUT called from a *test fixture* can be any code you wish to unit-test and does **not** need to be based on the [QP framework](https://www.state-machine.com/products/#QP). That way of applying QUTest is illustrated in the first three lessons of the @ref qutest_tut "QUTest Tutorial".

However, QUTest is particularly useful for testing QP applications, which is illustrated in the last two lessons of the @ref qutest_tut "QUTest Tutorial". In this case, the *test fixture* needs to initialize all used QP services, such as event pools to dispatch/post events to your state machines and active objects.

@note
The QP API implementation linked with the *test fixture* is **not** the actual QP framework, but instead just a  @ref qutest_stub "QUTest stub" described below.


------------------------------------------------------------------------------
@section qutest_stub QUTest&trade; Stub

(see <a href="https://www.state-machine.com/qpc/qutest_8c.html" target="_blank" class="extern">`qutest.c`</a>)


@next{qutest_script}
*/

/*###########################################################################*/
/*! @page qutest_script QUTest&trade; Script Reference

@tableofcontents

<p>A QUTest *test script* contains a group of related tests (a *test group*). The basic job of these tests is to send commands to the @ref qqtest_fixture "test fixture" running in the Target and to compare the @ref qspy_text "QSPY textual output" produced by the Target with the <a href="https://www.state-machine.com/glossary#test_expectation" class="extern"><b>expectations</b></a> of the tests.
</p>

The QUTest *test scripts* are executed in the host by the "QUTest front-end" that communicates with the @ref qspy "QSPY" host application via the @ref qspy_udp "UDP interface". The "QUTest front-end" is itself implemented in [Tcl](https://en.wikipedia.org/wiki/Tcl) (see <span class="img file_tcl">`qutest.tcl`</span>). This qutest.tcl file defines a small Domain Specific Language (DSL) for writing QUTest *test scripts*.

@remark
[Tcl (Tool Command Language)](https://en.wikipedia.org/wiki/Tcl) has been used to implement the small "QUTest DSL" for unit testing, because Tcl has been specifically designed as a tool for creating such "command languages".


------------------------------------------------------------------------------
@section qutest_qspy Categories of QSPY Output
To write effective *test scripts* you need to understand the main categories of QSPY output, which are illustrated in the picture below:

![Categories of QSPY output](qspy_cat.png)

<dl class="tag">
  <dt>[0]</dt><dd> Information output generated internally by QSPY. This output is *not* sent to *test scripts*.
  </dd>
  <dt>[1]</dt><dd> Dictionary trace records generated by the Target. This output is *not* forwarded to *test scripts*.
  </dd>
  <dt>[2]</dt><dd> Acknowledgement trace records generated by the Target. This output *is* forwarded to *test scripts*, but is checked automatically and implicitly by the *test commands*.
  </dd>
  <dt>[3]</dt><dd> Trace records generated by the Target. This output *is* forwarded to *test scripts* and must be checked **explicitly** by test expectations.
  </dd>
</dl>
<div style="clear:both;"></div>


@next{qspyview}
*/
