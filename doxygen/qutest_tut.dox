/*! @page qutest_tut QUTest&trade; Tutorial

<p>This Tutorial describes how to use the QUTest&trade; unit test harness in a series of progressively advancing examples. The first couple of examples pertain to generic C code completely unrelated to the QP frameworks. These examples are adaptations of tests described in the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a> by James W. Grenning. Later examples in this Tutorial show how to test <a href="https://www.state-machine.com/doc/concepts#HSM" target="_blank" class="extern">hierarchical state machines</a> and <a href="https://www.state-machine.com/doc/concepts#Active" target="_blank" class="extern">active objects</a>. It is highly recommended to study the simpler examples before the more advanced ones, as the basic information won't be repeated in the later tests.
</p>

As mentioned in the Section \"@ref qutest_how "How it works?"\", testing with QUTest&trade; always involves two components: (1) a @ref qutest_fixture "test fixture" code written in C (or C++) that runs on the Target and (2) a @ref qutest_script "test scipt(s)" that run on the host. This Tutorial starts each example with the description of how to run the tests and then explains the *test fixture* and the *test scripts* comprising the test.

@note
This Tutorial assumes that you run on Windows and that both QTools&trade; and QP&trade;/C framework have been installed in the default location (<span class="img folder">`C:\qp`</span> on Windows) and also that the **QTOOLS** environment variable has been defined and that the <strong>\%QTOOLS%\\bin</strong> directory has been added to the **PATH**. Please refer to the @ref install "QTools Installation" section for more information about downloading and installing QTools&trade;.


This Tutorial consists of the following lessons:

- @subpage qutest_tut_Sprintf
- @subpage qutest_tut_LedDriver
- @subpage qutest_tut_Mock
- @subpage qutest_tut_qhsm
- @subpage qutest_tut_qact

@next{qutest_tut_Sprintf}
*/

/*###########################################################################*/
/*! @page qutest_tut_Sprintf Sprintf Example

@tableofcontents

@htmlonly
<img style="float:right; margin:10px 8px 8px 15px; clear:right;" src="img/tddbook.gif" title="TDD Book">
@endhtmlonly

<p>This example is an adaptation of the tests described in Chapter 1 of the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a> by James W. Grenning. The example tests the `sprintf()` function from the C standard library, which means that you don't need to write the code that you will be testing (<b>C</b>ode <b>U</b>nder <b>T</b>est -- **CUT**).
</p>

@note
This simple example runs QUTest tests on the host (Windows in this case). Other examples in this Tutorial will also show how to run QUTest on embedded Targets.


------------------------------------------------------------------------------
@section qutest_sprintf-run Running the Test
The complete code for the Sprintf example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\TDDbook_Sprintf`</span>. To run the Sprintf tests (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY" host application with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open another command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\TDDbook_Sprintf
make SCRIPT=py
make
@endverbatim

This will build the @ref qutest_sprintf-fixture "Sprintf test fixture" as a Windows executable and then it will run the @ref qutest_sprintf-tcl "Sprintf test script (Tcl)". The screen shot below shows the output produced in these two command-prompt windows.

![QUTest sprintf() test run](test_sprintf.png)


------------------------------------------------------------------------------
@section qutest_sprintf-fixture Test Fixture
The job of a @ref qutest_fixture "test fixture" is to exercise the <a href="https://www.state-machine.com/glossary#CUT" class="extern"><b>CUT</b></a> (the `sprintf()` function in this case) and report the results back to the @ref qspy "QSPY host application". Note that a *test fixture* in QUTest&trade; is **not** supposed to perform any checks whether the CUT operates "correctly". Instead, your *test fixture* should only provide facilities to thoroughly exercise the **CUT** remotely from the  @ref qutest_sprintf-tcl "test script"(s). A properly written test fixture can be typically used for many tests (implemented in test scripts).

@remark
Coming up with a "good" *test fixture* requires some practice, but when you study the examples in this Tutorial, you will see examples of flexible *test fixtures* that allow you to to run a wide variety of tests on them.


The following listing shows the complete *test fixture* for the `sprintf()` tests (file <span class="img file_c">`test_Sprintf.c`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code
 [1] #include "qpc.h"    /* QUTest interface */
 [2] #include <stdio.h>  /* CUT interface */

 [3] Q_DEFINE_THIS_FILE

     /*--------------------------------------------------------------------------*/
 [4] static char format[20];
 [5] static char output[100];
 [6] static char string[20];

     enum {
 [7]    SPRINTF_CALL = QS_USER,
     };

     /*--------------------------------------------------------------------------*/
 [8] int main(int argc, char *argv[]) {

 [9]     QF_init();  /* initialize the framework and the underlying RT kernel */

         /* initialize the QS software tracing */
[10]     Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

[11]     /* dictionaries... */
         QS_OBJ_DICTIONARY(format);
         QS_OBJ_DICTIONARY(output);
         QS_OBJ_DICTIONARY(string);
         QS_USR_DICTIONARY(SPRINTF_CALL);

[12]     return QF_run(); /* run the tests */
     }
     /*--------------------------------------------------------------------------*/
[13] void QS_onTestSetup(void) {
     }
     /*..........................................................................*/
[14] void QS_onTestTeardown(void) {
     }

     /*..........................................................................*/
[15] void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         switch (cmdId) {
[16]         case 0: {   /* call the CUT and report results */
[17]             int ret = sprintf(&output[8],
                                   format, param1, string, param2, param3);
[18]             QS_BEGIN(SPRINTF_CALL, (void *)0) /* user-specific record */
[19]                 QS_U8(0, (uint8_t)ret);  /* return value */
[20]                 QS_STR(&output[8]);      /* produced string */
[21]             QS_END()
                 break;
             }
             default:
                 break;
         }
     }
     /*..........................................................................*/
     /* callback function to "massage" the injected QP events (not used here) */
[22] void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file includes the QP/C framework, which contains the QUTest interface. You need to include this header file in all QUTest test fixtures.
  </dd>
  <dt>[2]</dt><dd> You also need to include the interface to the CUT, which is `<stdio.h>` in case of the `sprintf()` CUT.
  </dd>
  <dt>[3]</dt><dd> The macro `Q_DEFINE_THIS_FILE` is needed for <a href="https://www.state-machine.com/glossary#assertion" class="extern"><b>DbC assertions</b></a> (they have nothing to do with <a href="https://www.state-machine.com/glossary#test_assertion" class="extern">test assertions</a>). Later in this file, a <a href="https://www.state-machine.com/glossary#assertion" class="extern">DbC assertion</a> is used to guard against failure in the initialization of the @ref qs "QS" target-resident component (see step [10]).
  </dd>
  <dt>[4]</dt><dd> The static (local) `char` array `format[]` will be used to provide the format string to the `sprintf()` CUT.
  </dd>
  <dt>[5]</dt><dd> The static (local) `char` array `output[]` will be used to provide the output buffer to the `sprintf()` CUT.
  </dd>
  <dt>[6]</dt><dd> The static (local) `char` array `string[]` will be used to provide a string parameter to the `sprintf()` CUT.
  </dd>
  <dt>[7]</dt><dd> The enumeration `SPRINTF_CALL` will be used for an @ref qs_app "application-specific" trace record that will report results of calling the `sprintf()` CUT in the Target.
> <b>NOTE:</b> that the enumeration is offset by #QS_USER.
  </dd>
  <dt>[8]</dt><dd> A QUTest *test fixture* code needs the `main()` function. This `main()` function can be in a separate file, but in this simple example it is placed in `test_Sprintf.c`. Either way, the `main()` function has the usual structure of a QP/C application (and in fact in the more advanced tests it can be *the same* function as used by the actual QP/C application). But here, it contains the bare minimum function calls, as described below.
  </dd>
  <dt>[9]</dt><dd> The `main()` function must start with calling `QF_init()` to initialize the QP framework.
  </dd>
  <dt>[10]</dt><dd> Next, you need to initialize the @ref qs "QS" target-resident component (QS_INIT()). This macro is wrapped with the <a class="extern" href="https://www.state-machine.com/qpc/qassert_8h.html#aa0c75140aa3855c94e453b06567dcc28"><b>Q_ALLEGE()</b></a> assertion, which will fire if the QS initialization fails. (In which case continuationon of the test makes no sense).
  </dd>
  <dt>[11]</dt><dd> Next, you produce @ref qs_dict "QS dictionaries" for all objects and @ref qs_app "application-specific" (user) trace records that the upcoming @ref qutest_sprintf-tcl "test scripts" need to know about.
> <b>NOTE:</b> you need to do this, so that the test scripts can refer to the objects by the same symbolic names as the *test fixture*.
  </dd>
  <dt>[12]</dt><dd> Finally, at the end of `main()` you need to call `QF_run()` to run the tests.
  </dd>
  <dt>[13]</dt><dd> The callback function `QS_onTestSetup()` allows you to include code that will be run at the beginning of each test. Here this simple `sprintf()` CUT does not need any setup, but you still need to provide (an empty) implementation to satisfy the linker.
  </dd>
  <dt>[14]</dt><dd> The callback function `QS_onTestTeardown()` allows you to include code that will be run at the end of each test. Here this simple `sprintf()` CUT does not need any teardown, but you still need to provide (an empty) implementation to satisfy the linker.
  </dd>
  <dt>[15]</dt><dd> The callback function `QS_onCommand()` allows you to remotely execute commands inside the Target. Here is where you execute the `sprintf()` CUT and report results back to QSPY.
  </dd>
  <dt>[16]</dt><dd> The command with `cmdId==0` will be used to call the `sprintf()` CUT.
> <b>NOTE:</b> You can use other `cmdId`s to call other pieces of CUT or to provide different variants of calling the same CUT, as you see fit. Much of the art of writing *test fixtures* lies in constructing flexible remote commands that exercise your CUT.
  </dd>
  <dt>[17]</dt><dd> The `sprintf()` CUT is called and the return value is saved in the `ret` automatic variable.
> <b>NOTE:</b> the output buffer (first argument of `sprintf()`) is not just the `output` array, but rather `&output[8]`, which will allow you to study buffer underflow (altering of the memory preceeding the buffer passed to `sprintf()`). Also note the other parameters of the call to the `sprintf()` CUT, such as the `format` string and the `string` argument. These details will be important to construct the @ref qutest_sprintf-tcl "test script"s.
  </dd>
  <dt>[18]</dt><dd> The `QS_BEGIN()` macro starts the @ref qs_app "application-specific" trace record that will report results of calling the `sprintf()` CUT to the Target.
  </dd>
  <dt>[19]</dt><dd> The `QS_U8()` macro sends a byte (`uint8_t`) to the Target. Here you output the return value from `sprintf()`, which is supposed to be the number of formatted arguments.
  </dd>
  <dt>[20]</dt><dd> The `QS_STR()` macro sends a zero-terminated string (`char` array) to the Target. Here you send the output buffer (please note the same offset of 8 as in the call to the  `sprintf()` CUT in line [17]).
  </dd>
  <dt>[21]</dt><dd> The `QS_END()` macro termiates the @ref qs_app "application-specific" trace record.
  </dd>
  <dt>[22]</dt><dd> The `QS_onTestEvt()` callback function is not used in this test, but needs to be provided to satisfy the linker.
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_sprintf-tcl Test Script (Tcl)
A **test script** contains a group of related tests (a <em>"test group"</em>). The basic job of these tests is to send commands to the *test fixture* running in the Target and to compare the @ref qspy_text "QSPY textual output" with the <a href="https://www.state-machine.com/glossary#test_expectation" class="extern"><b>expectations</b></a> of the test. The following listing shows the *test script* for the Sprintf tests (file <span class="img file_tcl">`test_Sprintf.tcl`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@remark
Even though a *test script* uses Tcl under the hood, you don't need to know Tcl to write effective tests. The actual set of commands that you use and need to know about forms a small "Domain Specific Language" (DSL) for unit testing, which just happens to be implemented with Tcl as a command interpreter.


@note
The following test script performs the same tests as the <a href="http://www.throwtheswitch.org/white-papers/unity-intro.html" target="_blank" class="extern">Unity</a> test fixture `SprintfTest.c` from the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a>. The file `SprintfTest.c` is provided in the directory <span class="img folder">`C:\qp\qpc\examples\qutest\TDDbook_Sprintf`</span>.


@code
 [1] # QUTEST test script corresponding to the test_Sprintf.c test fixture.
     # This example corresponds to SprintfTest.c from Chapter 2 "Test-Driving
     # Tools and Conventions" of the book: "Test-Driven Development for Embedded
     # Systems" by James W. Grenning

     # tests...

     #----------
 [2] test "No format operations"
 [3] glb_filter UA
 [4] current_obj AP format
 [5] poke 0 1 "Hello World!\0"
 [6] command 0
 [7] expect "0000000001 SPRINTF_CALL 12 Hello World!"
 [8] expect "0000000002 Trg-Done QS_RX_COMMAND"

     #----------
 [9] test "Insert decimal" -noreset
[10] current_obj AP format
[11] poke 0 1 "dec=%d\0"
[12] command 0 1234
[13] expect "0000000001 SPRINTF_CALL 8 dec=1234"
[14] expect "0000000002 Trg-Done QS_RX_COMMAND"

     #----------
[15] test "Insert decimal and string" -noreset
[16] current_obj AP format
[17] poke 0 1 "dec=%d, str=%s\0"
[18] current_obj AP string
[19] poke 0 1 "Hello\0"
[20] current_obj AP output
[21] fill 0 1 100 0xAA
[22] command 0 4321
[23] expect "0000000001 SPRINTF_CALL 19 dec=4321, str=Hello"
[24] expect "0000000002 Trg-Done QS_RX_COMMAND"

     #----------
[25] test "Overflow/underflow" -noreset
[26] current_obj AP output
[27] peek 26 1 4
[28] expect "%timestamp Trg-Peek Offs=26,Size=1,Num=4,Data=<??,00,AA,AA>"
[29] peek 0 1 10
[30] expect "%timestamp Trg-Peek Offs=0,Size=1,Num=10,Data=<AA,AA,AA,AA,AA,AA,AA,AA,??,??>"

     # the end
[31] end
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> Lines starting with a pound sign ('#') or empty lines are comments which are ignored by QUTest.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "No format operations"</strong> checks that `sprintf()` handles a format spec with no format opearations:
<dl class="tag">
  <dt>[2]</dt><dd> The @ref test() "test" command starts a test and gives it a name (in double quotes). The name of test will be displayed as the test is executed and should be a quick reminder about the objective of this test. This test command also @ref qutest_reset "resets the Target", which brings the Target into a well-defined initial state and produces the @ref qs_dict "QS dictionary records" (see @ref qutest_sprintf-fixture "test-fixture"[11])
  </dd>
  <dt>[3]</dt><dd> The **glb_filter** command sets the @ref qs_global "QS Global Filters" in the Target. Here the global filter allows all User trace records (UA). You need to open this filter to see the application-specific trace records, such as `SPRINTF_CALL` (see @ref qutest_sprintf-fixture "test-fixture"[7]).
  </dd>
  <dt>[4]</dt><dd> The **current_obj** command sets the @ref qs_curr "QS Current Object" in the Target. The `AP` argument means that the "Application Current Object" will be set inside the Target. This "Application Current Object" will be used in subsequent poke() command.
  </dd>
  <dt>[5]</dt><dd> The **poke** command pokes the specified "Application Current Object" starting with the specified offset from the beginning of the object in memory (here 0) with the data elements of size 1 (the second argument) with the data provided in the third argument ("Hello World!\0") into the previously established "Application Current Object" `format` (see @ref qutest_sprintf-fixture "test-fixture"[4]).
  </dd>
  <dt>[6]</dt><dd> The @ref command() "command" command causes the invocation of the `QS_onCommand()` callback inside the Target. The argument 0 is the `cmdId` parameter (see @ref qutest_sprintf-fixture "test-fixture"[16])
> **NOTE:** The first parameter of @ref command() "command" here is just a number (0), but it is also possible to use a **symbolic name** for the first parameter. This symbolic name will be looked up in the user dictionary (QS_USR_DICTIONARY()) produced by the Target, as illustrated in @ref qutest_leddriver-script "LedDriver Test Script"[2].
  </dd>
  <dt>[7]</dt><dd> The @ref expect() "expect" command represents an <a href="https://www.state-machine.com/glossary#test_expectation" class="extern"><b>expectation</b></a> of this test (a.k.a. <a href="https://www.state-machine.com/glossary#test_assertion">test assertion</a>). This is the expected output generated by the `command 0` command.
> <b>NOTE:</b> the expected string starts with a number `0000000001`, which is the @ref qs_tstamp "Target Time-Stamp". In QUTest, the @ref qutest_tstamp "timestamp" simply counts all the QS trace records produced, so that you know that no entries have been lost. In the later tests you will see how you can count the steps <b>automatically</b> with the `%timestamp` variable.
  </dd>
  <dt>[8]</dt><dd> The test finishes with the expectation for "Trg-Done" trace record, which means that all output generated by `command 0` has been generated.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "Insert decimal"</strong> challenges `sprintf()` to format a string with @c \%s :
<dl class="tag">
  <dt>[9]</dt><dd> The @ref test() "test" command starts a next test "Insert decimal". This test does **not** reset the Target (argument @ref qutest_reset "-noreset")
  </dd>
  <dt>[10]</dt><dd> The **current_obj** command sets again the @ref qs_curr "QS Current Object" in the Target.
  </dd>
  <dt>[11]</dt><dd> The **poke** command pokes the specified "Application Current Object" starting with the specified offset (here 0) with the data provided in the second argument. Here you poke a zero-terminated string "dec=%d\0" into the previously established Application Current Object `format`.
  </dd>
  <dt>[12]</dt><dd> The @ref command() "command" command causes the invocation of the `QS_onCommand()` callback inside the Target. The argument 0 is the `cmdId` parameter (see @ref qutest_sprintf-fixture "test-fixture"[16]).
  </dd>
  <dt>[13]</dt><dd> The @ref expect() "expect" command represents an <a href="https://www.state-machine.com/glossary#test_expectation" class="extern"><b>expectation</b></a> of this test. This is the expected output generated by the `command 0 1234` command.
  </dd>
  <dt>[14]</dt><dd> The test finishes with the expectation for the "Trg-Done" trace record, which means that all output generated by `command 0` has been generated.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "Insert decimal and string"</strong> challenges `sprintf()` to format both a string with @c \%s and a decimal with @c \%d:
<dl class="tag">
  <dt>[15]</dt><dd> The @ref test() "test" command starts a next test "Insert decimal and string". This test does **not** reset the Target (argument @ref qutest_reset "-noreset")
  </dd>
  <dt>[16]</dt><dd> The **current_obj** command sets again the @ref qs_curr "QS Current Object" in the Target.
  </dd>
  <dt>[17]</dt><dd> The **poke** command pokes the specified "Application Current Object" (now `format`) starting with the specified offset (here `0`) with the data provided in the second argument. Here you poke a zero-terminated string "dec=%d, str=%s\0" into the previously established Application Current Object `format`.
  </dd>
  <dt>[18]</dt><dd> The **current_obj** command changes the @ref qs_curr "QS Current Object" in the Target to `string`.
  </dd>
  <dt>[19]</dt><dd> The **poke** command pokes the specified "Application Current Object" (now `string`) starting with the specified offset (here `0`) with the data provided in the second argument. Here you poke a zero-terminated string "Hello\0" into the previously established Application Current Object `string`.
  </dd>
  <dt>[20]</dt><dd> The **current_obj** command changes the @ref qs_curr "QS Current Object" in the Target to `output`.
  </dd>
  <dt>[21]</dt><dd> The **fill** command fills the specified "Application Current Object" (now `output`) starting with the specified offset (here `0`) with the elements of size `1` (second argument), number of elements `100` (third argument) and the fill-data `0xAA` (forth argument).
  </dd>
  <dt>[22]</dt><dd> The @ref command() "command" command causes the invocation of the `QS_onCommand()` callback inside the Target. The argument 0 is the commandId. The second argument (`4321`) corresponds to `param1` in the @ref qutest_sprintf-fixture "test-fixture"[16].
  </dd>
  <dt>[23]</dt><dd> The @ref expect() "expect" command represents an **expectation** of this test (a.k.a. "test assertion"). This is the expected output generated by the `command 0 4321` command.
  </dd>
  <dt>[24]</dt><dd> The test finishes with the expectation for "Trg-Done" trace record, which means that all output generated by `command 0` has been generated.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "Overflow/underflow"</strong> checks whether `sprintf()` modifies its output buffer before the produced formatted output (underflow) or after the produced formatted output (overflow). Any such underflow/overflow would be a security problem, as it would open the door to the "buffer overrun" attacks:
<dl class="tag">
  <dt>[25]</dt><dd> The @ref test() "test" command starts a next test "Overflow/underflow". This test does **not** reset the Target (argument @ref qutest_reset "-noreset")
  </dd>
  <dt>[26]</dt><dd> The **current_obj** command sets again the @ref qs_curr "QS Current Object" in the Target.
  </dd>
  <dt>[27]</dt><dd> The **peek** command reads data from the specified "Application Current Object" (now `output`) starting with the specified offset (here `26`) with the data elements of size provided in the second argument (here `1`) and the number of such elements provided in the third argument (here `4`). Here you are reading bytes (elements size 1) at the end of the formatted output generated in the previouis test. You do this to check for any overflow of the `output` buffer.
  </dd>
  <dt>[28]</dt><dd> The @ref expect() "expect" command represents an **expectation** of this test (a.k.a. "test assertion"). This is the expected output generated by the `peek 26 1 4` command.
> <b>NOTE:</b> this expectation demonstrates the use of the @ref qutest_tstamp "\%timestamp variable" instead of hard-coded number like `0000000001`.@n
> <b>NOTE:</b> this expectation demonstrates also two "don't care" characters in the expected string (<b>'?'</b>). On the other hand, the expected values at the end of the `output` buffer are the zero-termination of the string (`'00'`) and two bytes `'AA,AA'` pre-filed in the previous test (step [21]).
  </dd>
  <dt>[29]</dt><dd> Another **peek** command reads the bytes (elements size 1) at the beginning of the formatted output generated in the previouis test. . You do this to check for any underflow of the `output` buffer.
  </dd>
  <dt>[30]</dt><dd> The @ref expect() "expect" command represents an **expectation** of this test (a.k.a. "test assertion"). This is the expected output generated by the `peek 0 1 10` command. Again, this expectation uses the @ref qutest_tstamp "\%timestamp variable" and "don't care" characters <b>'?'</b>.
  </dd>
  <dt>[31]</dt><dd> Every test script must end with the **end** command. This signals to the `qutest.tcl` test runner to output the test statistics.
> <b>NOTE:</b> a test script not terminated with an `end` command will generate an error.
  </dd>
</dl>
<div style="clear:both;"></div>

@remark
As an exercise you should modify the Sprintf *test script* to inject some errors and observe how the tests can fail.


------------------------------------------------------------------------------
@section qutest_sprintf-py Test Script (Python)
The following listing shows the Python *test script* for the Sprintf tests (file <span class="img file_py">`test_Sprintf.py`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@remark
Python *test scripts* is based on <a href="https://docs.pytest.org" target="_blank" class="extern">PyTest</a>. For this reason, the directory that holds Python test scripts must also contain the configuration file <span class="img file_py"><a target="_blank" class="extern" href="https://pytest.readthedocs.io/en/latest/plugins.html">`conftest.py`</a></span> shown below. This configuration file imports the common test fixtures used in the test scripts. @n
@n
`# Load common fixtures used throughout testing` @n
`from qspypy.fixtures import *`


@note
The following test script performs the same tests as the <a href="http://www.throwtheswitch.org/white-papers/unity-intro.html" target="_blank" class="extern">Unity</a> test fixture `SprintfTest.c` from the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a>. The file `SprintfTest.c` is provided in the directory <span class="img folder">`C:\qp\qpc\examples\qutest\TDDbook_Sprintf`</span>.


@code{.py}
 [1] # QUTEST test script corresponding to the test_Sprintf.c test fixture.
     # see https://www.state-machine.com/qtools/qutest.html
     #
     # This example corresponds to SprintfTest.c from Chapter 2 "Test-Driving
     # Tools and Conventions" of the book: "Test-Driven Development for Embedded
     # Systems" by James W. Grenning

 [2] import sys
 [3] import pytest
 [4] import struct
 [5] from qspypy.qspy import *

 [6] def test_No_format_operations(qutest):
         qutest.glb_filter(FILTER.UA)
         qutest.current_obj(QS_OBJ_KIND.AP,"format")
         qutest.command(0)
         qutest.poke(0,1,bytes("Hello World!\0",'ascii'))
         qutest.expect("0000000001 SPRINTF_CALL 12 Hello World!")
         qutest.expect("0000000002 Trg-Done QS_RX_COMMAND")

 [6] def test_Insert_decimal(qutest_noreset):
         qutest = qutest_noreset # name change
         qutest.current_obj(QS_OBJ_KIND.AP,"format")
         qutest.poke(0,1,bytes("dec=%d\0",'ascii'))
         qutest.command(0,1234)
         qutest.expect("0000000001 SPRINTF_CALL 8 dec=1234")
         qutest.expect("0000000002 Trg-Done QS_RX_COMMAND")

 [7] def test_Insert_decimal_and_string(qutest_noreset):
         qutest = qutest_noreset # name change
         qutest.current_obj(QS_OBJ_KIND.AP,"format")
         qutest.poke(0,1,bytes("dec=%d, str=%s\0",'ascii'))
         qutest.current_obj(QS_OBJ_KIND.AP,"string")
         qutest.poke(0,1,bytes("Hello\0",'ascii'))
         qutest.current_obj(QS_OBJ_KIND.AP,"output")
         qutest.command(0,4321)
         qutest.fill(0,1,100,0xAA)
         qutest.expect("0000000001 SPRINTF_CALL 19 dec=4321, str=Hello")
         qutest.expect("0000000002 Trg-Done QS_RX_COMMAND")

     def test_Overflow_underflow(qutest_noreset):
         qutest = qutest_noreset # name change
         qutest.current_obj(QS_OBJ_KIND.AP,"output")
         qutest.peek(26,1,4)
         qutest.expect("%timestamp Trg-Peek Offs=26,Size=1,Num=4,Data=<6F,00,AA,AA>")
         qutest.peek(0,1,10)
         qutest.expect("%timestamp Trg-Peek Offs=0,Size=1,Num=10,Data=<AA,AA,AA,AA,AA,AA,AA,AA,*")


     if __name__ == "__main__":
         options = ['-x', '-v', '--tb=short']
         options.extend(sys.argv)
         pytest.main(options)
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> Lines starting with a pound sign ('#') or empty lines are comments which are ignored by QUTest.
  </dd>
</dl>
<div style="clear:both;"></div>

@next{qutest_tut_LedDriver}
*/

/*##########################################################################*/
/*! @page qutest_tut_LedDriver LedDriver Example

@tableofcontents

@htmlonly
<img style="float:right; margin:10px 8px 8px 15px; clear:right;" src="img/tddbook.gif" title="TDD Book">
@endhtmlonly

<p>This example is an adaptation of the tests described in Chapters 2 and 3 of the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a> by James W. Grenning. The example tests a simple "LED Driver" that turns on and off several LEDs in a LED strip. The <a href="https://www.state-machine.com/glossary#CUT" class="extern"><b>CUT</b></a> for this example is located in the file <span class="img file_c">`LedDriver.c`</span> in the same directory as the rest of this test.
</p>


------------------------------------------------------------------------------
@section qutest_leddriver-run Running the Test
The complete code for the LedDriver example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\TDDbook_LedDriver`</span>. To run the LedDriver tests (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY" host application with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open another command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\TDDbook_LedDriver
make
@endverbatim

This will build the @ref qutest_sprintf-fixture "LedDriver test fixture" as a Windows executable and then it will run the @ref qutest_leddriver-script "LedDriver test script". The screen shot below shows the output produced in these two command-prompt windows.

![QUTest LedDriver test run](test_leddriver.png)


------------------------------------------------------------------------------
@section qutest_leddriver-fixture Test Fixture
The following listing shows the test fixture for the LedDriver tests (file <span class="img file_c">`test_LedDriver.c`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
 [1] #include "qpc.h"       /* QUTest interface */
 [2] #include "LedDriver.h" /* CUT */

     Q_DEFINE_THIS_FILE

     /*--------------------------------------------------------------------------*/
 [3] static uint16_t virtualLeds;

     enum {
 [4]     LEDDRIVER_CREATE  = QS_USER,
         LEDDRIVER_DESTROY,
         LEDDRIVER_TURNON,
         LEDDRIVER_TURNOFF,
         LEDDRIVER_TURNALLON,
         LEDDRIVER_TURNALLOFF,
         LEDDRIVER_ISON,
         LEDDRIVER_ISOFF,
     };

     /*--------------------------------------------------------------------------*/
 [5] int main(int argc, char *argv[])  {

         QF_init();  /* initialize the framework */

         /* initialize the QS software tracing */
         Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

         /* filter setup */
 [6]     QS_FILTER_ON(QS_UA_RECORDS); /* UA==user-all */

         /* dictionaries... */
 [7]     QS_OBJ_DICTIONARY(&virtualLeds);
 [8]     QS_USR_DICTIONARY(LEDDRIVER_CREATE);
         QS_USR_DICTIONARY(LEDDRIVER_DESTROY);
         QS_USR_DICTIONARY(LEDDRIVER_TURNON);
         QS_USR_DICTIONARY(LEDDRIVER_TURNOFF);
         QS_USR_DICTIONARY(LEDDRIVER_TURNALLON);
         QS_USR_DICTIONARY(LEDDRIVER_TURNALLOFF);
         QS_USR_DICTIONARY(LEDDRIVER_ISON);
         QS_USR_DICTIONARY(LEDDRIVER_ISOFF);

         return QF_run(); /* run the tests */
     }

     /*--------------------------------------------------------------------------*/
     void QS_onTestSetup(void) {
 [9]    LedDriver_Create(&virtualLeds);
     }
     /*..........................................................................*/
     void QS_onTestTeardown(void) {
 [10]   LedDriver_Destroy();
     }
     /*..........................................................................*/
     void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         (void)param2;
         (void)param3;
         BOOL ret;

         switch (cmdId) {
 [11]        case LEDDRIVER_CREATE: {
 [12]            LedDriver_Create(&virtualLeds);
 [13]            QS_BEGIN(LEDDRIVER_CREATE, (void *)0) /* user-specific record */
 [14]                QS_U32_HEX(4, (uint32_t)virtualLeds);
                 QS_END()
                 break;
             }
             case LEDDRIVER_DESTROY: {
                 LedDriver_Destroy();
                 QS_BEGIN(LEDDRIVER_DESTROY, (void *)0) /* user-specific record */
                    QS_U32_HEX(4, (uint32_t)virtualLeds);
                 QS_END()
                 break;
             }
             case LEDDRIVER_TURNON: {
                 LedDriver_TurnOn((int)param1);
                 QS_BEGIN(LEDDRIVER_TURNON, (void *)0) /* user-specific record */
                    QS_U32_HEX(4, (uint32_t)virtualLeds);
                 QS_END()
                 break;
             }
             case LEDDRIVER_TURNOFF: {
                 LedDriver_TurnOff((int)param1);
                 QS_BEGIN(LEDDRIVER_TURNOFF, (void *)0)
                    QS_U32_HEX(4, (uint32_t)virtualLeds);
                 QS_END()
                 break;
             }
             ~ ~ ~
             default:
                 break;
         }
     }
     /*..........................................................................*/
     /*! callback function to "massage" the injected QP events (not used here) */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file includes the QP/C framework, which contains the QUTest interface. You need to include this header file in all QUTest test fixtures.
  </dd>
  <dt>[2]</dt><dd> The `"LedDriver.h"` header file includes CUT interface.
  </dd>
  <dt>[3]</dt><dd> The `virtualLeds` static variable is used in the `LedDriver` CUT.
  </dd>
  <dt>[4]</dt><dd> The enumerated constants `LEDDRIVER_xxx` will be used for @ref qs_app "application-specific trace records" that will report results of calling the various functions of the LedDriver CUT in the Target.
> <b>NOTE:</b> that the enumeration is offset by #QS_USER.
  </dd>
  <dt>[5]</dt><dd> This simple *test fixture* again directly contains the main() function. This function contains the bare minimum function calls, as described below.
  </dd>
  <dt>[6]</dt><dd> The QS_FILTER_ON(QS_UA_RECORDS) macro opens up the @ref qs_global "QS Global Filter" for all user (i.e., application-specific) records (the `QS_UA_RECORDS` group). This is an alternative to issuing the command `"glb_filter UA"` from the *test script*.
> <b>NOTE:</b> QUTest starts with all @ref qs_global "QS Global Filter" disabled.
  </dd>
  <dt>[7]</dt><dd> The macro QS_OBJ_DICTIONARY(&virtualLeds) generates an object-dictionary entry for the `virtualLeds` variable.
  </dd>
  <dt>[8]</dt><dd> The macros QS_USR_DICTIONARY() generate user-dictionary entries for all application-specific (user) trace records enumerated in step [4].
  </dd>
  <dt>[9]</dt><dd> The callback function `QS_onTestSetup()` is used here to create the LedDRiver before every test.
> <b>NOTE:</b> The `QS_onTestSetup()` callback is called for every @ref test() "test" command in the *test script*.
  </dd>
  <dt>[10]</dt><dd> The callback function `QS_onTestTeardown()` is used here to destroy the LedDRiver after every test.
> <b>NOTE:</b> The `QS_onTestTeardown()` callback is called for every @ref test() "test" command in the *test script*.
  </dd>
  <dt>[11]</dt><dd> The `QS_onCommand()` callback is used to call the CUT, whereas each function of the driver is called in the different `case` of the switch. Please note that here the `cmdId`s are the same as the application-specific trace records enumerated in step [4]. This will allow the *test script* to use symbolic names for commands, instead of hard-coded numerical values.
  </dd>
  <dt>[12]</dt><dd> For example, the `case LEDDRIVER_CREATE` calls the `LedDriver_Destroy()` function from the CUT
  </dd>
  <dt>[13]</dt><dd> Subsequently, the application-specific trace record `LEDDRIVER_CREATE` is generated.
  </dd>
  <dt>[14]</dt><dd> This trace record outputs the value of `virtualLeds` produced by the call to the CUT. Similar strategy is used in all remaining `case` statements in the `QS_onCommand()` callback function.
  </dd>
</dl>
<div style="clear:both;"></div>

------------------------------------------------------------------------------
@section qutest_leddriver-script Test Script
The following listing shows the *test script* for the LedDriver tests (file <span class="img file_tcl">`test_LedDriver.tcl`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@note
The following test script performs the same tests as the <a href="http://www.throwtheswitch.org/white-papers/unity-intro.html" target="_blank" class="extern">Unity</a> test fixture `LedDriverTest.c` from the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a>. The file `LedDriver.c` is provided in the directory <span class="img folder">`C:\qp\qpc\examples\qutest\TDDbook_LedDriver`</span>.

@code
     # QUTEST test script corresponding to the test_LedDriver.c test fixture.
     # This example corresponds to LedDriver.c from Chapters 3 & 4 "Starting
     # a C Module" & "Testing Your Way to Done" of the book: "Test-Driven
     # Development for Embedded Systems" by James W. Grenning

     # tests...

     #----------
 [1] test "LEDs off after Create"
 [2] command LEDDRIVER_CREATE
 [3] expect "%timestamp LEDDRIVER_CREATE 0x0000"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
     test "Turn on LED(1)" -noreset
     command LEDDRIVER_TURNON 1
     expect "%timestamp LEDDRIVER_TURNON 0x0001"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
     test "Turn off LED(1)" -noreset
     command LEDDRIVER_TURNOFF 1
     expect "%timestamp LEDDRIVER_TURNOFF 0x0000"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
     test "Turn on multiple LEDs" -noreset
     command LEDDRIVER_TURNON 9
     expect "%timestamp LEDDRIVER_TURNON 0x0100"
     expect "%timestamp Trg-Done QS_RX_COMMAND"
     command LEDDRIVER_TURNON 8
     expect "%timestamp LEDDRIVER_TURNON 0x0180"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     ~ ~ ~

     #----------
     test "LED memory is not readable" -noreset
     current_obj AP virtualLeds
     poke 0 2 [binary format s 0xFFFF]
     peek 0 2 1
     expect "%timestamp Trg-Peek Offs=0,Size=2,Num=1,Data=<FFFF>"
     command LEDDRIVER_TURNON 8
     expect "%timestamp LEDDRIVER_TURNON 0x0080"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     # the end
     end
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The @ref test() "test" command starts the first test of the group. The first test command must @ref qutest_reset "reset the Target", which brings the Target into a well-defined initial state and produces the QS dictionary records (see @ref qutest_leddriver-fixture "test-fixture"[5]).
  </dd>
  <dt>[2]</dt><dd> This @ref command() "command" illustrates the use of a symbolic name for the `cmdId` paramter. The symbolic name `LEDDRIVER_CREATE` comes from the @ref qs_dict "user dictionary" produced in @ref qutest_leddriver-fixture "test-fixture"[8].
  </dd>
  <dt>[3]</dt><dd> The @ref expect() "expect" command corresponds to the @ref qs_app "user-record" `LEDDRIVER_CREATE` generated in @ref qutest_leddriver-fixture "test-fixture"[13]. Note that the value of the `virtualLeds` variable sent in this user-record is formatted in hex, which corresponds to the macro `QS_U32_HEX()` in @ref qutest_leddriver-fixture "test-fixture"[14].
  </dd>
</dl>
<div style="clear:both;"></div>

@note
As you can see, the QUTest&trade; environment enables you to write *test scritps* entirely in terms of the symbols used in the *test fixture*. (You could use hex addesses, if you wished, but this is obviously not recommended.) The key is to generate appropriate @ref @ref qs_dict "QS dictionaries" from the *test fixture*.


@next{qutest_tut_Mock}
*/

/*###########################################################################*/
/*! @page qutest_tut_Mock Mock Object Example

@tableofcontents

@htmlonly
<img style="float:right; margin:10px 8px 8px 15px; clear:right;" src="img/tddbook.gif" title="TDD Book">
@endhtmlonly

<p>This example is an adaptation of the Flash-memory unit tests described in Chapter 10 "The Mock Object" of the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a> by James W. Grenning. The example tests a Flash-memory driver (for the M28W160ECT Flash Memory device from Micron Technology).

In case of the Flash memory driver (the <a href="https://www.state-machine.com/glossary#CUT" class="extern"><b>CUT</b></a> in this case), it collaborates with the low-level IO (input/output) code, which is responsible for reading and writing data to raw memory addresses. Hence, the most important aspect of this example is the use of a **Mock Object** for simulating the low-level input/output interface to the Flash memory. The <b>CUT</b> for this example is located in the file <span class="img file_c">`Flash.c`</span> in the same directory as the rest of this test.
</p>

@remarks
In the classic unit testing harnesses based on the xUnit principles, a mock object is a specific variant of a <a href="https://www.state-machine.com/glossary#test_double" class="extern"><b>test double</b></a> that is needed to verify complex, multi-stage interactions between the CUT and the collaborator impersonated by the mock test double (test-script -> CUT -> mock-object).

@note
Because of the different design philosophy of QUTest, which is *not* based on xUnit, the classic "mock object" is actually not needed and can be replaced with a simpler "spy" test double. To dynamically alter the behavior of this "spy" test double, this example applies @ref qutest_probe "QUTest Test Probes". Test Probes can be changed interactively from the @ref qutest_flash-script "test script".


------------------------------------------------------------------------------
@section qutest_flash-run Running the Test
The complete code for the Flash example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\TDDbook_Flash`</span>. To run the Flash tests (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY" host application with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open another command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\TDDbook_Flash
make
@endverbatim

This will build the @ref qutest_flash-fixture "Flash test fixture" as a Windows executable and then it will run the @ref qutest_flash-script "Flash test script". The screen shot below shows the output produced in these two command-prompt windows.

![QUTest Flash test run](test_flash.png)


------------------------------------------------------------------------------
@section qutest_flash-mock Mock Object
The following listing shows the mock object for the low-level IO (input/outpu) operations implemented with QUTest&trade; (file <span class="img file_c">`MockIO.c`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
 [1] #include "qpc.h" /* for QUTEST */
 [2] #include "IO.h"  /* mocked interface */

     enum {
 [3]     IO_CALL = QS_USER1,
     };

     /*..........................................................................*/
 [4] void MockIO_Init(void) {
         /* dictionaries... */
 [5]     QS_USR_DICTIONARY(IO_CALL);

 [6]     QS_FUN_DICTIONARY(&IO_Read);
         QS_FUN_DICTIONARY(&IO_Write);
     }
     /*..........................................................................*/
 [7] ioData IO_Read(ioAddress offset) {
 [8]     QS_TEST_PROBE_DEF(&IO_Read)
         ioData ret = (ioData)0;
 [9]     QS_TEST_PROBE(
[10]         ret = (ioData)qs_tp_;
         )
[11]     QS_BEGIN(IO_CALL, (void *)0) /* user-specific record */
[12]         QS_FUN(&IO_Read);
[13]         QS_I16(0, ret);
[14]         QS_U32(0, offset);
         QS_END()
[15]     return ret;
     }
     /*..........................................................................*/
[16] void IO_Write(ioAddress offset, ioData data) {
[17]     QS_BEGIN(IO_CALL, (void *)0) /* user-specific record */
[18]         QS_FUN(&IO_Write);
[19]         QS_U32(0, offset);
[20]         QS_I16(0, data);
         QS_END()
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file includes the QP/C framework, which contains the QUTest interface. Typically, you need to include this header file in QUTest test doubles.
  </dd>
  <dt>[2]</dt><dd> The `"IO.h"` header file specifies the interface to the code being mocked. The whole purpose of the mock is to implement this interface such that the CUT can call use it as its collaborator.
> **NOTE:** The CUT does not "know" that it is collaborating with a _test double_ (the mock object in this case).
  <dt>[3]</dt><dd> This enumeration lists the @ref qs_app "application-specific QS trace records" that will be produced by the mocked IO operations. The enumeration starts with #QS_USER1 offset, which is the second group of user-specific records. The first group (#QS_USER0 offset) is used by the main @ref qutest_flash-fixture "test fixture".
  </dd>
  <dt>[4]</dt><dd> The `MockIO_init()` function performs the initialization of the mock object. This function is not part of the real IO interface (see `IO.h` in the Flash test directory), but is needed only for testing.
  </dd>
  <dt>[5]</dt><dd> The initialization produces @ref qs_dict "user dictionaries" for application-specific trace records produced by the mock.
> **NOTE:** such "dictionaries" will allow the @ref qutest_flash-script "test script" to refer to the produced application-specific records by their symbolic names.
  </dd>
  <dt>[6]</dt><dd> The initialization produces @ref qs_dict "function dictionaries" for the low-level IO functions implemented by the mock.
> **NOTE:** such "dictionaries" will allow the @ref qutest_flash-script "test script" to refer to the functions by their symbolic names.
  </dd>
  <dt>[7]</dt><dd> The `IO_Read()` function is one of the low-level IO operations implemented by the mock.
> **NOTE:** Perhaps the most important aspect of the `IO_Read()` function is the return value it provides to the CUT, which is the error status.
  </dd>
  <dt>[8]</dt><dd> The macro QS_TEST_PROBE_DEF() retrieves the @ref qutest_probe "Test Probe" for this function (argument `&IO_Read`). The "Test Probe" means a 32-bit data item that the @ref qutest_flash-script "test script" has provided for this function before calling it.
  </dd>
  <dt>[9]</dt><dd> The QS_TEST_PROBE() macro utilizes the test probe retrieved by the QS_TEST_PROBE_DEF() macro. If the test probe has been provided (the 32-bit value is not zero) the code in parentheses (step [10]) is executed.
  </dd>
  <dt>[10]</dt><dd> The 32-bit value of the test probe is copied to the return value from the function.
> **NOTE:** that way the mocked `IO_Read()` function can return to the CUT a value pre-programmed by the @ref qutest_flash-script "test script".
  </dd>
  <dt>[11]</dt><dd> The application-specific trace record `IO_CALL` is generated.
  </dd>
  <dt>[12]</dt><dd> The specific IO function is reported, which will produce the symbolic name of the function in QSPY (the dictionary for this function has been produced in step [6]).
  </dd>
  <dt>[13]</dt><dd> The return value is reported as `int16_t`.
  </dd>
  <dt>[14]</dt><dd> The memory `offset` parameter is reported as `uint32_t`.
  </dd>
  <dt>[15]</dt><dd> The fake return value is returned to the CUT.
  </dd>
  <dt>[16]</dt><dd> The `IO_Write()` function is another low-level IO operation implemented by the mock.
  </dd>
  <dt>[17]</dt><dd> The application-specific trace record `IO_CALL` is generated.
  </dd>
  <dt>[18]</dt><dd> The specific IO function is reported, which will produce the symbolic name of the function in QSPY (the dictionary for this function has been produced in step [6]).
  </dd>
  <dt>[19]</dt><dd> The memory `offset` parameter is reported as `uint32_t`.
  </dd>
  <dt>[20]</dt><dd>  The memory `data` parameter is reported as `int16_t`.
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_flash-fixture Test Fixture
The following listing shows the test fixture for the Flash tests (file <span class="img file_c">`test_Flash.c`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
 [1] #include "qpc.h"       /* QUTest interface */
 [2] #include "Flash.h"     /* CUT */
 [3] #include "FakeMicroTime.h" /* test double */

     Q_DEFINE_THIS_FILE

     /* mock initialization -----------------------------------------------------*/
     enum {
 [4]     FLASH_WRITE = QS_USER0,
 [5]     FAKE_MICROTIME_INIT,
     };

 [6] void MockIO_Init(void);

     /*--------------------------------------------------------------------------*/
     int main(int argc, char *argv[]) {

         QF_init();  /* initialize the framework */

         /* initialize the QS software tracing */
         Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

         /* filter setup */
         QS_FILTER_ON(QS_UA_RECORDS); /* UA==user-all */

         /* dictionaries... */
         QS_USR_DICTIONARY(FLASH_WRITE);
         QS_USR_DICTIONARY(FAKE_MICROTIME_INIT);

         QS_FUN_DICTIONARY(&Flash_Create);
         QS_FUN_DICTIONARY(&Flash_Destroy);
         QS_FUN_DICTIONARY(&Flash_Write);

         /* initialize the mocks... */
 [7]     MockIO_Init();

         return QF_run(); /* run the tests */
     }

     /*--------------------------------------------------------------------------*/
     void QS_onTestSetup(void) {
 [8]     Flash_Create();
     }
     /*..........................................................................*/
     void QS_onTestTeardown(void) {
 [9]     Flash_Destroy();
     }
     /*..........................................................................*/
     void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         (void)param2;
         (void)param3;

         switch (cmdId) {
[10]         case FLASH_WRITE: {
[11]             int ret = Flash_Write((ioAddress)param1, (ioData)param2);
[12]             QS_BEGIN(FLASH_WRITE, (void *)0) /* user-specific record */
[13]                QS_I32(0, ret);
                 QS_END()
                 break;
             }
[14]         case FAKE_MICROTIME_INIT: {
[15]             FakeMicroTime_Init(param1, param2);
[16]             QS_BEGIN(FAKE_MICROTIME_INIT, (void *)0) /* user-specific record */
                 QS_END()
                 break;
             }
             default:
                 break;
         }
     }
     /*..........................................................................*/
     /*! callback function to "massage" the injected QP events (not used here) */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file includes the QP/C framework, which contains the QUTest interface. Typically, you need to include this header file in QUTest test doubles.
  </dd>
  <dt>[2]</dt><dd> The `"Flash.h"` header file specifies the interface to the CUT.
  <dt>[3]</dt><dd> The `"FakeMicroTime.h"` header file includes the test double for the `MicroTime` service, as described in the TDD book.
  </dd>
> **NOTE:** The CUT does not "know" that it is collaborating with a _test double_ (the `FakeMicroTime` in this case).
  <dt>[4]</dt><dd> This enumeration lists the @ref qs_app "application-specific QS trace records" that will be produced by the test fixture (see the `QS_onCommand()` callback at the end of the test fixture). The enumeration starts with #QS_USER0 offset, which is the first group of user-specific records. The second group (#QS_USER1 offset) is used by the `MockIO.c` mock object.
  </dd>
  <dt>[5]</dt><dd> This enumeration is for the @ref qs_app "application-specific QS trace record" that will exercise the `FakeMicroTime_Init()` service.
  </dd>
  <dt>[6]</dt><dd> The `MockIO_init()` function performs the initialization of the mock object. This function is not part of the real IO interface (see `IO.h` in the Flash test directory), but is needed only for testing.
  </dd>
  <dt>[7]</dt><dd> The `MockIO_init()` initialization outputs @ref qs_dict "user dictionaries" for application-specific trace records produced by the mock.
> **NOTE:** such "dictionaries" will allow the @ref qutest_flash-script "test script" to refer to the produced application-specific records by their symbolic names.
  </dd>
  <dt>[8]</dt><dd> The `QS_onTestSetup()` callback creates the Flash object, mimicking the functionality described in the TDD book.
  </dd>
  <dt>[9]</dt><dd> The `QS_onTestTeardown()` callback destroys the Flash object, mimicking the functionality described in the TDD book.
  </dd>
  <dt>[10]</dt><dd> The `FLASH_WRITE` command (enumerated in line [4]) exercises the the `Flash_write()` CUT function.
  </dd>
  <dt>[11]</dt><dd> The command calls the CUT `Flash_write()` function with the provided parameters @p param1 and @p param2 .
  </dd>
  <dt>[12]</dt><dd> The command reports also that the function was called using an @ref qs_app "application-specific trace record".
  </dd>
  <dt>[13]</dt><dd> The @ref qs_app "application-specific trace record" reports also the return value from the CUT function.
  </dd>
  <dt>[14]</dt><dd> The `FLASH_MICROTIME_INIT` command (enumerated in line [5]) exercises the the `FakeMicroTime_Init()` function from the test double.
  </dd>
  <dt>[15]</dt><dd> The command calls the `FakeMicroTime_Init()` function with the provided parameters @p param1 and @p param2 .
  </dd>
  <dt>[16]</dt><dd> The command reports also that the function was called using an @ref qs_app "application-specific trace record".
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_flash-script Test Script
The following listing shows the *test script* for the Flash tests (file <span class="img file_tcl">`test_Flash.tcl`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@note
The following test script performs the same tests as the <a href="https://cpputest.github.io/" target="_blank" class="extern">CppUtest</a> test fixture <span class="img file_cpp">`FlashTest.cpp`</span> from the book <a href="https://wingman-sw.com/test-driven-development-for-embedded-c-book" target="_blank" class="extern">"Test-Driven Development for Embedded C"</a>.

@code
     # QUTEST test script corresponding to the test_Flash.c test fixture.
     # This example corresponds to FlashTest.cpp test from Chapter 10 "The Mock
     # Object" of the book: "Test-Driven Development for Embedded Systems" by
     # James W. Grenning

     # preamble...

 [1] proc on_setup {} {
 [2]     command FAKE_MICROTIME_INIT 0 1
 [3]     expect "%timestamp FAKE_MICROTIME_INIT"
 [4]     expect "%timestamp Trg-Done QS_RX_COMMAND"
     }

 [5] set address 0x1000
 [6] set data    [expr (0xBEEF << 16) >> 16] ;# sign-extend

     # constants from "Flash.h"
 [7] set FLASH_SUCCESS                0
     set FLASH_VPP_ERROR              1
     set FLASH_PROGRAM_ERROR          2
     set FLASH_PROTECTED_BLOCK_ERROR  3
     set FLASH_UNKNOWN_PROGRAM_ERROR  4
     set FLASH_READ_BACK_ERROR        5
     set FLASH_TIMEOUT_ERROR          6

     # constants from "m28w160ect.h"
 [8] set CommandRegister         [expr 0x0]
     set StatusRegister          [expr 0x0]

     set ProgramCommand          [expr 0x40]
     set Reset                   [expr 0xFF]

     set ReadyBit                [expr 1<<7]
     set EraseSuspendBit         [expr 1<<6]
     set EraseErrorBit           [expr 1<<5]
     set ProgramErrorBit         [expr 1<<4]
     set VppErrorBit             [expr 1<<3]
     set ProgramSuspendBit       [expr 1<<2]
     set BlockProtectionErrorBit [expr 1<<1]
     set ReservedBit             [expr 1<<0]

     # tests...

     #----------
 [9] test "Write success ready immediately"
[10] probe IO_Read $ReadyBit
[11] probe IO_Read $data
[12] command FLASH_WRITE $address $data
[13] expect "%timestamp IO_CALL IO_Write $CommandRegister $ProgramCommand"
[14] expect "%timestamp IO_CALL IO_Write $address $data"
[15] expect "%timestamp TstProbe Fun=IO_Read,Data=128"
[16] expect "%timestamp IO_CALL IO_Read $ReadyBit $StatusRegister"
[17] expect "%timestamp TstProbe Fun=IO_Read,Data=$data"
[18] expect "%timestamp IO_CALL IO_Read [expr $data] $address"
[19] expect "%timestamp FLASH_WRITE $FLASH_SUCCESS"
[20] expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
[21] test "Write success not immediately ready" -noreset
[22] probe IO_Read 0
     probe IO_Read 0
     probe IO_Read 0
     probe IO_Read $ReadyBit
     probe IO_Read $data
[23] command FLASH_WRITE $address $data
     expect "%timestamp IO_CALL IO_Write $CommandRegister $ProgramCommand"
     expect "%timestamp IO_CALL IO_Write $address $data"
     expect "%timestamp TstProbe Fun=IO_Read,Data=0"
     expect "%timestamp IO_CALL IO_Read 0 $StatusRegister"
     expect "%timestamp TstProbe Fun=IO_Read,Data=0"
     expect "%timestamp IO_CALL IO_Read 0 $StatusRegister"
     expect "%timestamp TstProbe Fun=IO_Read,Data=0"
     expect "%timestamp IO_CALL IO_Read 0 $StatusRegister"
     expect "%timestamp TstProbe Fun=IO_Read,Data=128"
     expect "%timestamp IO_CALL IO_Read $ReadyBit $StatusRegister"
     expect "%timestamp TstProbe Fun=IO_Read,Data=$data"
     expect "%timestamp IO_CALL IO_Read [expr $data] $address"
     expect "%timestamp FLASH_WRITE $FLASH_SUCCESS"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
[24] test "Write fails Vpp Error" -noreset
[25] probe IO_Read [expr $ReadyBit | $VppErrorBit]
     command FLASH_WRITE $address $data
     expect "%timestamp IO_CALL IO_Write $CommandRegister $ProgramCommand"
     expect "%timestamp IO_CALL IO_Write $address $data"
     expect "%timestamp TstProbe Fun=IO_Read,Data=[expr $ReadyBit | $VppErrorBit]"
     expect "%timestamp IO_CALL IO_Read [expr $ReadyBit | $VppErrorBit] $StatusRegister"
     expect "%timestamp IO_CALL IO_Write $CommandRegister $Reset"
     expect "%timestamp FLASH_WRITE $FLASH_VPP_ERROR"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
     test "Write fails Program Error" -noreset
     ~ ~ ~

     #----------
     test "Write fails Protected-Block Error" -noreset
     ~ ~ ~

     #----------
     test "Write fails Unknown Program Error" -noreset
     ~ ~ ~

     #----------
     ~ ~ ~

     #----------
     test "Write sucess Ignores Other Bits Until Ready" -noreset
     ~ ~ ~

     #----------
     test "Write fails Timeout" -noreset
     command FAKE_MICROTIME_INIT 0 500
     expect "%timestamp FAKE_MICROTIME_INIT"
     expect "%timestamp Trg-Done QS_RX_COMMAND"
[26] for {set i 0} {$i < 10} {incr i} {
         probe IO_Read [expr ~$ReadyBit]
     }
     command FLASH_WRITE $address $data
     expect "%timestamp IO_CALL IO_Write $CommandRegister $ProgramCommand"
     expect "%timestamp IO_CALL IO_Write $address $data"
[27] for {set i 0} {$i < 10} {incr i} {
         expect "%timestamp TstProbe Fun=IO_Read,Data=[expr ~$ReadyBit]"
         expect "%timestamp IO_READ [expr ~$ReadyBit] $StatusRegister"
     }
     expect "%timestamp FLASH_WRITE $FLASH_TIMEOUT_ERROR"
     expect "%timestamp Trg-Done QS_RX_COMMAND"

     #----------
     test "Write fails Timeout at End-Of-Time" -noreset
     ~ ~ ~

     # the end
     end
@endcode

<dl class="tag">
  <dt>[1]</dt><dd>
The script procedure `on_setup()` is executed at the beginning of each test in the group (see test()), including both tests that reset and don't reset the Target.
  </dd>
  <dt>[2]</dt><dd>
This @ref command() "command" illustrates the use of a symbolic name for the cmdId paramter. The symbolic name `FAKE_MICROTIME_INIT` comes from the user dictionary produced in the @ref qutest_flash-fixture "test fixture".
  </dd>
    <dt>[3]</dt><dd>
This expectation checks that the output of the command `FAKE_MICROTIME_INIT` is produced (see @ref qutest_flash-fixture "test fixture"[14])
  </dd>
  <dt>[4]</dt><dd>
The expectation checks that the "Trg-Done" trace record is produced, which means that all output generated by command in step [2] has been generated.
  </dd>

> **NOTE:** A test script allows you to define named constants, and the following lines illustrate several ways you can do it.

  <dt>[5]</dt><dd>
This line defines a constant "address" and assigns it a value 0x1000.
  </dd>
  <dt>[6]</dt><dd>
This line defines a constant "data" and assings it a value of an expression (note that the expression starts with <a href="http://www.tcl.tk/man/tcl8.4/TclCmd/expr.htm" class="extern">Tcl expr command</a> and is surrounded with `[]`).
  </dd>
  <dt>[7]</dt><dd>
This group of constants comes from the `Flash.h` header file and represents various errors reprted by the Flash device.
  </dd>
  <dt>[8]</dt><dd>
This group of constants comes from the `m28w160ect.h` header file and represents various addresses and bits inside the M28W160ECT Flash Memory device.
  </dd>
  <dt>[9]</dt><dd>
The @ref test() "test" command starts a first test "Write success ready immediately". As usual, the first test resets the Target (the `-noreset` option is not allowed).
  </dd>
  <dt>[10]</dt><dd>
The @ref probe() "probe" command sends a @ref qutest_probe "Test Probe" to the Target. This test probe is for the function `IO_Read()` and its value is `$ReadyBit` (note the **$** in front of the constant `ReadyBit`).
> **NOTE:** The meaning of a given Test Probe depends entirely on its use in the code. Consequently, you need to consult the implementation of the `IO_Read()` function defined in the @ref qutest_flash-mock "mock object"[8]. In this case, the Test Probe is used as a return value from the `IO_Read()` function.
  </dd>
  <dt>[11]</dt><dd>
The @ref probe() "probe" command sends another @ref qutest_probe "Test Probe" to the Target. This test probe is again for the function `IO_Read()` and its value is `$data` (note the **$** in front of the variable `data`).
  </dd>
  <dt>[12]</dt><dd>
This @ref command() "command" executes the `FLASH_WIRTE` command with arguments `$address` and `$data` (see also [5] and [6]).
  </dd>
  <dt>[13]</dt><dd>
This @ref expect() "expect" command corresponds to the user-record `IO_WRITE` generated from @ref qutest_flash-mock "mock-object"[16].
  </dd>
  <dt>[14]</dt><dd>
This @ref expect() "expect" command corresponds to the user-record `IO_WRITE` generated from @ref qutest_flash-mock "mock-object"[16].
  </dd>
  <dt>[15]</dt><dd>
This @ref expect() "expect" command corresponds to retreiving the Test Probe in the @ref qutest_flash-mock "mock-object"[8]. This is the first Test Probe for the `IO_Read()` function, which was sent at step [10].
  </dd>

> **NOTE:** The @ref qs "QS" target component is designed to report back to the host any externally-triggered activities that might impact the flow of control. Retreiving a @ref qutest_probe "Test Probe" is obviously one of such activities.

  <dt>[16]</dt><dd>
This @ref expect() "expect" command corresponds to the user-record `IO_WRITE` generated from @ref qutest_flash-mock "mock-object"[11].
  </dd>
  <dt>[17]</dt><dd>
This @ref expect() "expect" command corresponds to retreiving the Test Probe in the @ref qutest_flash-mock "mock-object"[8]. This is the second Test Probe for the `IO_Read()` function, which was sent at step [11].
  </dd>
  <dt>[18]</dt><dd>
This @ref expect() "expect" command corresponds to the user-record `IO_WRITE` generated from @ref qutest_flash-mock "mock-object"[11].
  </dd>
  <dt>[19]</dt><dd>
This @ref expect() "expect" command corresponds to the user-record `FLASH_WRITE` generated from @ref qutest_flash-fixture "test fixture"[12].
  </dd>
  <dt>[20]</dt><dd>
The test finishes with the expectation for "Trg-Done" trace record, which means that all output generated by `command FLASH_WRITE` has been generated.
  </dd>
  <dt>[21]</dt><dd>
The @ref test() "test" command starts a seconf test "Write success not immediately ready". This test does not perform reset of the Target (the `-noreset` argument)
  </dd>

> **NOTE:** The test still causes execution fo the `on_setup()` function defined for the whole group of tests at step [1].

  <dt>[22]</dt><dd>
The @ref probe() "probe" command sends a @ref qutest_probe "Test Probe" to the Target.
  </dd>

> **NOTE:** This probe happens to have the default value 0, which causes the default behavior in the Target code that is identical with the situation when no Test Probe is availalbe. However, you still need to provide such Test Probe, because of the run-to-completion execution of the CUT in the @ref qutest_flash-fixture "test fixture"[10].

  <dt>[23]</dt><dd>
This @ref command() "command" executes the CUT (`Flash_Write()` function).
  </dd>
  <dt>[24]</dt><dd>
The @ref test() "test" command starts the test ""Write fails Vpp Error". This test is the first that tests for error conditions in the Flash device. Please note how easy it is to fake the error responses from the @ref qutest_flash-mock "mock-object" by setting up the appropriate Test Probes.
  </dd>
  <dt>[25]</dt><dd>
This `for`-loop illustrates how to use loop constructs to generate several similar test commands in the script.
  </dd>

> **NOTE:** The number of Test Probes that you can setup in the Target at any given time is currently limited to 20. Every new test clears all Test Probes, so you have the full set of probes to your disposal at the beginning of each test

  <dt>[26]</dt><dd>
This `for`-loop corresponds to the Test Probes setup in the for-loop at step [25].
  </dd>
</dl>
<div style="clear:both;"></div>

@next{qutest_tut_qhsm}
*/

/*###########################################################################*/
/*! @page qutest_tut_qhsm Hierarchical State Machine Example

@tableofcontents
<p>This example shows how to apply QUTest for unit-testing [Hierarchical State Machines](https://www.state-machine.com/doc/concepts.php#HSM). This example illustrates two testing strategies for state machines:
</p>

- **Functional tests** focus on the *actions* performed by the state machine.

- **Structural tests** focus on the state machine structure, such as entering/exiting *states* and executing *state transitions*.


In practice, unit-testing of state machines typically involves a mixture of these functional and structural testing strategies.

@note
As described in the @ref qutest_tut_Mock, testing of complex, multi-stage interactions (such as a state machine) typically requires application of a "mock object" test double. However, the QUTest design philosophy allows you to use much simpler "spy" test double instead. This tutorial illustrates this approach for *functional testing* of hierarchical state machines.


------------------------------------------------------------------------------
@section qutest_qhsm-cut The QHsmTst State Machine
The hierarchical state machine used in this example is a bit artificial, but it has been specifically designed to contain all possible state transition topologies for up to 4 levels of state nesting. The code representing this state machine  (the CUT here), has been generated automatically by the [QM modeling tool](https://www.state-machine.com/qm/) from the model shown in the screen-shot below:

![QHsmTst state machine in QM](qhsmtst_qm.png)

The state machine executes actions on every entry/exit to states, on state transitions and on internal state transitions. These actions are all implemented by calling the `BSP_display()` function that outputs a succinct message about the location of the action within the state machine. For example, the entry action to state "s2" calls `BSP_display("s2-ENTRY;")` and the exit action from state "s2" calls `BSP_display("s2-EXIT;")`. These actions then are used for @ref qutest_qhsm-funct-script "functional testing" of the state machine.


------------------------------------------------------------------------------
@section qutest_qhsm-run Running the Test
The complete code for the `qhsm` example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\qhsmtst`</span>. To run the `qhsm` tests (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY" host application with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open another command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\qhsmtst
make
@endverbatim

This will build the @ref qutest_qhsm-fixture "QHsm test fixture" as a Windows executable and then it will run the @ref qutest_qhsm-funct-script "QHsm test script". The screen shot below shows the output produced in these two command-prompt windows.

![QUTest QHsm test run](test_qhsm.png)


------------------------------------------------------------------------------
@section qutest_qhsm-fixture Test Fixture
The following listing shows the test fixture for the QHsm tests (file <span class="img file_c">`test_qhsm.c`</span>). This test fixture is used in both @ref qutest_qhsm-funct-script "functional" and @ref qutest_qhsm-struct-script "structural" tests. The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
     #include "qpc.h"       /* QUTest interface */
     #include "qhsmtst.h"   /* CUT */

     Q_DEFINE_THIS_FILE

     enum {
 [1]     BSP_DISPLAY = QS_USER,
     };

     /*--------------------------------------------------------------------------*/
     int main(int argc, char *argv[]) {
         static QF_MPOOL_EL(QEvt) smlPoolSto[10]; /* small pool */

         QF_init();    /* initialize the framework */

         /* initialize the QS software tracing */
         Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

         /* initialize event pools... */
         QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(smlPoolSto[0]));

         /* dictionaries... */
 [2]     QS_FUN_DICTIONARY(&QHsm_top);
 [3]     QS_OBJ_DICTIONARY(the_hsm);
 [4]     QS_USR_DICTIONARY(BSP_DISPLAY);

 [5]     QHsmTst_ctor(); /* instantiate the QHsmTst object */

         return QF_run();
     }

     /*--------------------------------------------------------------------------*/
 [6] void BSP_display(char const *msg) {
 [7]     QS_BEGIN(BSP_DISPLAY, (void *)0) /* application-specific record */
 [8]         QS_STR(msg);
         QS_END()
     }

     /*..........................................................................*/
     void BSP_exit(void) {
     }

     /*--------------------------------------------------------------------------*/
     void QS_onTestSetup(void) {
     }
     /*..........................................................................*/
     void QS_onTestTeardown(void) {
     }
     /*..........................................................................*/
     void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         (void)param1;
         (void)param2;
         (void)param3;

         switch (cmdId) {
            case 0U: {
                break;
            }
            default:
                break;
         }
     }

     /*..........................................................................*/
     #ifdef Q_HOST  /* is this test compiled for a desktop Host computer? */
     /*! host callback function to "massage" the event, if necessary */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
     #else /* this test is compiled for an embedded Target system */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
     #endif
@endcode
<dl class="tag">
  <dt>[1]</dt><dd> The `BSP_DISPLAY` enumeration will be used as the record-ID for the @ref qs_app "application-specific trace record".
  </dd>
> **NOTE:** The record-ID is offset by #QS_USER.
  <dt>[2]</dt><dd> This line produces a @ref qs_dict "function dictionary" for the [QHsm_top() function](https://www.state-machine.com/qpc/qep_8h.html#ac8ae4728dfab5ce26a907fc624f6e104).
  </dd>
  <dt>[3]</dt><dd> This line produces a @ref qs_dict "object dictionary" for the `l_hsm` state machine object to test.
  </dd>
  <dt>[4]</dt><dd> This line produces a @ref qs_dict "user dictionary" for the application-specific trace record defined at label [1].
  </dd>
  <dt>[5]</dt><dd> The "constructor" of the state machine object is called.
  </dd>
> **NOTE:** The explicit "constructor" call is needed only in C. In C++ static constructors are called automatically as part of the startup sequence.
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_qhsm-act Action Functions Test Doubles
For functional testing, which is focused on the **actions** performed by a state machine, the actions must generate some QS output. This QS instrumentation can be added either directly to the state machine model, or indirectly to the functions called from the state machine actions. The test fixture above illustrates the second option, because it was more convenient in this case (see `BSP_display()` implementation starting at label [6] above).

<dl class="tag">
  <dt>[6]</dt><dd> The function `BSP_display()` is called from all actions of the state machine. Inside the test fixture, this function is defined to produce QS output. This is a classic example of a "spy" test double.
  </dd>
  <dt>[7]</dt><dd> The QS output is produced with an @ref qs_app "application-specific trace record" enumerated at label [1]. The second argument to the QS_BEGIN() macro is zero, which means that this   record does not use any @ref qs_local "local filter".
  </dd>
  <dt>[8]</dt><dd> The QS_STR() data element outputs the message string.
  </dd>
</dl>
<div style="clear:both;"></div>


In practice, you will likely use both methods at the same time. Simple actions that don't perform any hardware-specific operations could be instrumented directly in the state machines. The hardware-specific actions need to be abstracted anyway (in the BSP for "dual targeting"), in which case you can place the QS instrumentation in the BSP only.


------------------------------------------------------------------------------
@section qutest_qhsm-funct-script Test Script (Functional Testing)
The following listing shows the *test script* for the QHsm tests (file <span class="img file_tcl">`test_qhsm-funct.tcl`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code
     # QUTEST test of QHsmTst functional

     # preamble...
 [1] proc on_reset {} {
 [2]     glb_filter UA
 [3]     current_obj SM the_hsm
     }

     # tests...
[4]  test "QHsmTst init"
[5]  init
[6]  expect "%timestamp BSP_DISPLAY top-INIT;"
     expect "%timestamp BSP_DISPLAY s-ENTRY;"
     expect "%timestamp BSP_DISPLAY s2-ENTRY;"
     expect "%timestamp BSP_DISPLAY s2-INIT;"
     expect "%timestamp BSP_DISPLAY s21-ENTRY;"
     expect "%timestamp BSP_DISPLAY s211-ENTRY;"
 [6] expect "%timestamp Trg-Done QS_RX_EVENT"

     #------------------
 [7] test "QHsmTst dispatch" -noreset

 [8] dispatch A_SIG
 [9] expect "%timestamp BSP_DISPLAY s21-A;"
     expect "%timestamp BSP_DISPLAY s211-EXIT;"
     expect "%timestamp BSP_DISPLAY s21-EXIT;"
     expect "%timestamp BSP_DISPLAY s21-ENTRY;"
     expect "%timestamp BSP_DISPLAY s21-INIT;"
     expect "%timestamp BSP_DISPLAY s211-ENTRY;"
[10] expect "%timestamp Trg-Done QS_RX_EVENT"

     dispatch B_SIG
     expect "%timestamp BSP_DISPLAY s21-B;"
     expect "%timestamp BSP_DISPLAY s211-EXIT;"
     expect "%timestamp BSP_DISPLAY s211-ENTRY;"
     expect "%timestamp Trg-Done QS_RX_EVENT"

     ~ ~ ~
     # the end
     end
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The script procedure `on_reset()` is executed after each reset of the target. This is in contrast to the procedure `on_setup()`, which is executed at the begin of all tests, including tests that don't reset the target.
  </dd>
  <dt>[2]</dt><dd> The @ref qs_global "global filter" is set to `UA`, which means "all user trace records". This filter setting determines the character of the test to be a **functional** test, because the focus is on the trace records produced by actions (user trace records) rather than the @ref qs_pre "pre-defined records" generated by executing a state machine.
  </dd>

</dl>
<div style="clear:both;"></div>



------------------------------------------------------------------------------
@section qutest_qhsm-struct-script Test Script (Structural Testing)
The following listing shows the *test script* for the QHsm tests (file <span class="img file_tcl">`test_qhsm-struct.tcl`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code
# QUTEST test of QHsmTst structural

# preamble...
proc on_reset {} {
    glb_filter SM
    current_obj SM the_hsm
}

# tests...
test "QHsmTst init"
init
expect "===RTC===> St-Init  Obj=the_hsm,State=QHsm_top->QHsmTst_s2"
expect "===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s"
expect "===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s2"
expect "===RTC===> St-Init  Obj=the_hsm,State=QHsmTst_s2->QHsmTst_s211"
expect "===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s21"
expect "===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s211"
expect "%timestamp Init===> Obj=the_hsm,State=QHsmTst_s211"
expect "%timestamp Trg-Done QS_RX_EVENT"

#------------------
test "QHsmTst dispatch" -noreset

dispatch A_SIG
expect "%timestamp Disp===> Obj=the_hsm,Sig=A_SIG,State=QHsmTst_s211"
expect "===RTC===> St-Exit  Obj=the_hsm,State=QHsmTst_s211"
expect "===RTC===> St-Exit  Obj=the_hsm,State=QHsmTst_s21"
expect "===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s21"
expect "===RTC===> St-Init  Obj=the_hsm,State=QHsmTst_s21->QHsmTst_s211"
expect "===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s211"
expect "%timestamp ===>Tran Obj=the_hsm,Sig=A_SIG,State=QHsmTst_s21->QHsmTst_s211"
expect "%timestamp Trg-Done QS_RX_EVENT"

~ ~ ~
# the end
end
@endcode

@next{qutest_tut_qact}
*/

/*###########################################################################*/
/*! @page qutest_tut_qact Active Object Example

@tableofcontents

------------------------------------------------------------------------------
@section qutest_qact-cut The Active Objects in Dining Philosophers Problem


@next{qutest_rtc}
*/

